#  计算机概论

[Crash Course 计算机视频](https://www.bilibili.com/video/av21376839?p=1)

[Crash Course字幕组](https://crashcourse.club/)

[Crash Course官方](https://www.patreon.com/crashcourse)

| | | | | | | | |
|-|-|-|-|-|-|-|-|
| | | | | | | | |

markdown 扩展语法

2^7^  

H~2~O  

$\lim_{x \to \infty} \exp(-x) = 0$



## 1.计算机的早期历史

美索不达米亚 1000 BC 算盘

| time          | area                         | Instance                   | 进制 |
| ------------- | ---------------------------- | -------------------------- | ---- |
| 1000BC        | 美索不达米亚                 | 算盘                       | 10   |
| 1694          | 德国                         | 步进计算器                 | 10   |
| before 20 C   | world                        | 计算表                     |      |
| 1822          | 英国（Charles Babbage）      | 差分机（论文）             |      |
| 1822-1842     | 英国(Charles Babbage)        | 分析机（general computer） |      |
| 18X（8\|9）？ | 美国（Hollerith IBM 创始人） | 打孔卡片制表机             |

Ada Lovelace 给分析机写了假象程序(第一程序员)

Charles Babbage 设计了分析机，即通用计算机 （计算机之父）

## 2.电子计算机

机械继电器（开关），利用电磁线圈的磁场把开关吸下来，联通电路

二极管 （首先出现为热电子管）

三级真空管（二代继电器），每秒客开闭千次

1947 贝尔实验室 晶体管（半导体材料继电器），每秒万次开闭，加州硅谷，出现仙童半导体公司，仙童来变成了英特尔，目前的晶体管体积50纳米，每秒上百万次开闭，工作几十年，



| time    | area          | instance | person        | remarks                                  |
| ------- | ------------- | -------- | ------------- | ---------------------------------------- |
| 1944    | IBM           | Mark II  | IBM           | 1947 pulled a bug                        |
| 1943.12 | 英国Bletchley | Mark I   | Tommy Flowers | 大规模使用真空管(1600)，可编程，解密Nazi |
| 1941    | 英国Bletchley | Bombe    | Alan Turing   | designd to break Enigma code             |
| 1946    | 美            | ENIAC    | Pennsylvania  | 积分，真正意义电子计算机                 |
| 1958    | 美            | IBM608   | IBM           | 使用晶体管                               |

## 3.布尔逻辑与逻辑门

##### [布尔代数](http://www.ruanyifeng.com/blog/2016/08/boolean-algebra.html)

关于真值的逻辑运算称为布尔代数（Boolean Algebra），以它的创始人布尔命名。

在编程语言中表示T值和F值的数据类型叫做布尔类型，在C语言中通常用`int`类型来表示，非0表示T，0表示F。布尔逻辑是写程序的基本功之一，程序中的很多错误都可以归因于逻辑错误。

```
以下是一些布尔代数的基本定理，为了简洁易读，T和F用1和0表示，AND用*号表示，OR用+号表示（从真值表可以看出AND和OR运算确实有些类似*和+），NOT用¬表示，x、y、z的值可能是0也可能是1。
```

```
¬¬x=x

x*0=0
x+1=1

x*1=x
x+0=x

x*x=x
x+x=x

x*¬x=0
x+¬x=1

x*y=y*x
x+y=y+x

x*(y*z)=(x*y)*z
x+(y+z)=(x+y)+z

x*(y+z)=x*y+x*z
x+y*z=(x+y)*(x+z)

x+x*y=x
x*(x+y)=x

x*y+x*¬y=x
(x+y)*(x+¬y)=x

¬(x*y)=¬x+¬y
¬(x+y)=¬x*¬y

x+¬x*y=x+y
x*(¬x+y)=x*y

x*y+¬x*z+y*z=x*y+¬x*z
(x+y)*(¬x+z)*(y+z)=(x+y)*(¬x+z)

除了第1行之外，这些公式都是每两行一组的，每组的两个公式就像对联一样：把其中一个公式中的*换成+、+换成*、0换成1、1换成0，就变成了与它对称的另一个公式。这些定理都可以通过真值表证明
```





##### 逻辑门 and or not xor



###### and

| true  | true  | true  |
| ----- | ----- | ----- |
| true  | false | false |
| false | true  | false |
| false | false | false |

###### or

| true  | true  | true  |
| ----- | ----- | ----- |
| true  | false | true  |
| false | true  | true  |
| false | false | false |

###### not


| true  | false |
| ----- | ----- |
| false | true  |

###### xor


| true  | true  | false |
| ----- | ----- | ----- |
| true  | false | true  |
| false | true  | true  |
| false | false | false |

## 4.二进制

##### 二进制，逢二进一

| 2^7^ | 2^6^ | 2^5^ | 2^4^ | 2^3^ | 2^2^ | 2^1^ | 2^0^ |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | 1    | 1    | 0    | 1    | 0    | 0    |
二进制中，

一个0或1表示一位（1bit）

8bit = 1byte(字节)

1kb = 2^10^ byte = 1024 byte



##### 数字表示

###### 整数

0 000 0000    0000 0000    0000 0000    0000 0000

首位表示正负（sign）其余为数值

###### 浮点数

0 000 0000    0 000 0000    0000 0000    0000 0000

浮点数是将科学计数法的数字进行存储，首位表示正负（sign）接下来八位 表示指数，剩下的23位表示有效位数

例如

153446631161563的科学计数法表示 0.153446631161563 x 10^15^

它的浮点数如下 4字节的浮点数精度损失还是比较大

0 000 0111    1 100 0101    1100 0111    1000 1001‬

##### 字符的表示

字符表示最简单的方法就是给字母一个编号，就有了ASCII

为了表示the world的所有字符，后来就出现了Unicode和ISO，之后他们俩兼容了，现在常用的编码实现位utf-8,它是一种可变长的编码，<a href="#####utf-8">utf-8编码规则</a>



##### unicode

```
正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。

可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。

Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。
```

##### unicode的问题

```
需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。

比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。

这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。

它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。
```

##### utf-8

```
互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。

UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。

UTF-8 的编码规则很简单，只有二条：

1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。

2）对于n字节的符号（n > 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。

下表总结了编码规则，字母x表示可用编码的位。

```

| Unicode符号范围(十六进制) | UTF-8编码方式（二进制）             |
| ------------------------- | ----------------------------------- |
| 0000 0000-0000 007F       | 0xxxxxxx                            |
| 0000 0080-0000 07FF       | 110xxxxx 10xxxxxx                   |
| 0000 0800-0000 FFFF       | 1110xxxx 10xxxxxx 10xxxxxx          |
| 0001 0000-0010 FFFF       | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |

```
跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。

下面，还是以汉字严为例，演示如何实现 UTF-8 编码。

严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。
```

引用

[字符编码笔记：ASCII，Unicode 和 UTF-8]( http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html )

## 5.算数逻辑单元ALU (Arithmetic & Logic Unit)

How Computer Calculate ——the ALU

##### 计算单元



###### 加法实现

###### a half adder

进行1bit运算

<img src="http://47.103.65.182/markdown/040.png">

###### 全加器

full adder 使用两个 half adder实现

<img src="http://47.103.65.182/markdown/041.png">

###### 8bit adder

<img src="http://47.103.65.182/markdown/042.png">

<img src="http://47.103.65.182/markdown/043.png">

##### 逻辑单元

 布尔运算 and or not xor 

对输入的信号，进行逻辑运算，结果符合真值表



##### ALU抽象

<img src="http://47.103.65.182/markdown/044.png">

